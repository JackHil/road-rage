# TODO #

hackathon topics:
  math to stop
  order for reservation policy
  timing for cycle light policy
  lets make sure length corresponds to reality (in m or km)
  slow down for turns if needed

  lane-changing
  online spawning
  mikes wards
  pick a client app

- when dt_s = max_dt = 0.1, bad things happen... why?
  we begin stopping when our stopping distance... all thats correct
  but stopping dist occurs in some time thats bigger than this value
  but while we're stopping, we try to cover half the remaining dist in max_dt!!! unrealistic.

  ??? sometimes we're going too fast..
    - we're going faster than what should be possible?

  1) understand piyush's optimal way, instead.
  2) silly alt is to just adjust max_dt, actual_dt, or the value used for predictions?

  3) idea: accel = max_deaccel to reach end. one correction lets us do that?
     possibly... dist we want to cover in a step is... dist we COULD cover in a step, going at
     max_deaccel? min of that and actual dist left?

  4) piyush's way: cover minimum distance needed to keep invariant:
      stopping_distance > dist_left + (max_dt * cur_speed)
     aka finalize v_f at the end of this next tick


  piyush's way, revised:
  
  if we continued at current velocity, we wouldnt be able to stop...
    *** or if we sped up the max?
  stopping_dist(cur_v) >= dist_left - (cur_v * max_dt)
  stopping_dist(v) = v^2 / (2 * a_max)   this is correct

  minimize the time taken to complete this stopping dist.
    v_cur' = vel after this tick
    dist_left' = dist left after this tick
    dist_tick = dist we will travel in this tick
  so of course dist_left = dist_tick + dist_left'

  to minimize time, reduce speed by as little as possible (aka maximize v_cur')
  and then slam on brakes. this condition gives
    dist-left' = stopping_dist(v_cur')

  ....

  distance_tick = v_current * dt + 1/2 (v_current_prime - v_current) * dt 
                = 1/2 (v_current_prime + v_current) * dt

  plug in...

  solve for v_current_prime'; make that the speed we accelerate to. take the greater of the solns.
    distance_left = 1/2 (v_current_prime + v_current) * dt + v_current_prime^2 / (2 * a_max)


  
  and make sure to have a buffer for where we stop.

  



- maintain some minimum distance between cars (problem)

- test reservation policy
  - we do deadlock!
  - tell the intersection who we are behind, and make sure our turn will be satisfied after theirs
    in the queue.
  *** but then they will have to schedule their turn first...

- with both policies, observed an agent overtaking another... does avoiding the next agent
  really work?

- if we do piyush's optimal way, we pick the right time to start, set the right accel to make it work

- ui could show policy's current owner or something

* online traffic spawning
* lane changing
* slow down for turns

- cyclic traffic signal mode
  - do we need an event scheduling system?

- can we get total deterministicness in headless mode?

### Map building ###

- our pruning of pedestrian ways seems to be a bit too enthusiastic (see Guadalupe St)
- deterministic construction is still wonky, with both ward IDs and lines (due to meeting up)
- make line segs meet up better.
- style: xml out could be string.format or xml and then stringify, or use lazy?
- cul-de-sac handling in p2... needed?
  - Claus Circle in BR... has no outgoing turns.
- pregraph3 vs final graph structure?
- scc removal is broken
  - being on a directed graph DOES change things... we're detecting an scc and not handling the
    one-way edge leading into it!
- multi-lane situations dont have enough turns, and we need to do more trimming!
- lane reversal
  1) Traversable.location starts from the other end (distances, queues all stay same)
  2) dynamically recalculating turns

### Wards ###

- whats broken with mikes?
  - length
  - overall strategy
  - semantics of one of the set operations
- find 'major' roads better
  - crosses/links major roads
  - manually editing
  - update osm (scripts!)
- my wards!
  - guarantee some kind of connectedness within a ward

### UI ###

- show routes better
- config
- menu items doing stuff
- make it look nicer
  - UI polishing
  - black road backgrounds dont meet up smoothly since we go by line segment
    - add extra lanes on either side, dont color them white, but draw the stuff in between?
- figure out why broken_angle and y inversion everywhere still...
- way better pruning of what to (re-draw) using quadtrees
  - but is it even needed?
- keyboard-grabbing focus is... greedy when minimized
- dont show arrows when line segs are really clustered

### Agents ###

- old static behavior
  - lack of determinism?
    - timesteps matter / crossing many things in one hop
      - if an agent can only adjust speed once per timestep... oops.
    - patho case: two lanes merging, agent on each, order matters.

  - detect collisions
    - post-mortem checker still misses scary things in between, like when merging.
    - force collisions, see if they're detected. set one guy on the road and make him be still!
    - ui show collisions

  - lots of things break if we have a vertex with a self-loop

  - enforce speed limits
  - test with stalled car
  - make them slow down for turns

- lanechanging model
- spawning safely
- delegate pricy work to a thread pool
- spawning specifically in UI
- dimensions to the cars (solved by maintaining fixed dist)
- structuring policy stuff as a state machine and events may be more elegant...

### Scalaisms ###

- move all configable things to Util
- use ListBuffers more.
- make more immutable things
- reduce more vars to vals
- improve build system (dont recompile)
- Edges as subclasses for direxn might be nice
- make everything possible immutable, but then have to figure out how to build
  inter-referential things
  - Mutable subclasses of everything used during construction..
  - have more ids and methods that access based on those. that'll break it.
- explicitly override hashcode?

### Simulation ###

- tolling
- lane reversal
- 4-way stops
- traffic signals
- dynamic traffic signals
- spawning realistic traffic patterns
  http://sumo.sourceforge.net/doc/current/docs/userdoc/Demand/Introduction_to_demand_modelling_in_SUMO.html
  http://sumo.sourceforge.net/doc/current/docs/userdoc/Data/Traffic_Data.html
- promoting stop signs -> lights
- mixing intersections!

### Administrative ###

- documentation
- API and code freeze
- paper
