# TODO #

# Easy Parallelization
- how to PAR
  - benchmark carefully

- easy PAR
  - queue end_step
  - intersection end_step
  - intersection reaction
  - lookahead

- hard PAR: agent steps
  - dont forget handle_exit
  - LCing means chunking by road
  - figure out where everyone ends up, then merge queues in one thread?

# Fastpaths / Sparse Execution
- agents and intersections could wake each other up now

# Map Construction
- keep orig GPS coords and only scale around for UI
- xml output too for non-aorta clients
- clean up roads with just 2 roads
  - pass3, since doomed pruning makes new problems
  - but keep pass 2 version? seems to prevent some stuff from getting doomed!
- short roads into longer turns
  * get rid of the hack that adds length to short roads upon creation
  - 50 meters?
  - dont nix roads connected to vertices with only one road!
  - bernwood drive and other places where the number blows up

  - fix the geometry stuff later. what stuff?
    - maybe remove set_lines?
  - remove ui debugging stuff
- make turns better, more systematically
  - try to not remove pieces of maps at all

- use http://wiki.openstreetmap.org/wiki/Relation:restriction
- our pruning of pedestrian ways seems to be a bit too enthusiastic (see Guadalupe St)
- deterministic construction is still wonky, with ward IDs and lines (due to meeting up)
- cul-de-sac handling in p2... needed?
  - Claus Circle in BR... has no outgoing turns.
- connectivity fixpoint algorithm shouldnt be necessary?
- make xml as complete as plaintext?
- lots of things break if we have a vertex with a self-loop

# Simulation Realism
- slow down for turns (a speed limit)
- diversity... different vehicle lengths, parameters
- calibration issues... distances totally off
- have a notion of "I'm done with the turn, but I'm protruding into the intersection"
  by requiring not only we're done with a turn but also some dist along the new edge.
- give lanes/roads/etc the ability to be closed

# Code Cleanup
- a Common object
- pull some math in one place
- split the passes
  - pass1 = read osm + normalize
  - pass2 = pass2
  - pass3 = (>make edge geometry), make edges, make turns,
            (>nuke disconnected), (collapse degenerate verts),
            (small roads to long turns), trim lane lines at vertices
- only really legit use of scheduled sim events is generators, stats
- draw per object
  - UI state needs to go somewhere accessible to all
  - package for awt stuff to avoid importing
- sorted sets everywhere for determinism
- more privates, make abstract members more explicit, delegates
- move all configable things to Util
- make more immutable things / reduce more vars to vals
- make everything possible immutable, but then have to figure out how to build
  inter-referential things
  - Mutable subclasses of everything used during construction..
  - have more ids and methods that access based on those. that'll break it.
  - immutable construction is easy... have parent entity create child.

# Contraction Hierarchies
- understand...
- waypoints, in the meantime
  - handle when we dont follow the waypt->goal path well
  - choose waypoints better
- better router interface

# Intersection Policies
- stop sign for only some directions
- backpressure light optimization
- agents should tell intersections in advance when they know
  - the edge case when we intend to stop

# Scaling
- tighten memory usage, although 1GB supports 1 million agents
- we can do much better with ready agents... max capacity of edges, group them
  based on where they want to spawn, maybe by generator?
- gridlock?
  - force different turns?
  - agents get caught in loops because the path isnt realizable due to LC
- at big timesteps, nobody moves?

# Testing/Experiments
- standalone programs to make/mod scenarios
- make scenarios from UI
- the stats side of the story
- verify determinism retained... ordering events queue
- things to test
  - wacky cases of 2 side-by-side agents wanting to swap places?

# UI
- javafx?
- 3D
- visualize red/green lights better
- cmdline switch to follow stuff or zoom in somewhere
- ui speed controls.. step one tick, display a certain fps, sleep to match what?
- visualize lookahead
- turn off generators
- color agents from diff generators a certain way
- right click context menus
- show 'fps' in viewer
- config

# Lane-changing
- any missed opportunities?
- dont let agents start lc that depends on others getting out of way
- lookbehind is feasible with lazy floodfilling
- speculative desired_lane

# Micro-optimizations
- sleep less in UI
- throw away geometry in UI after converted to awt stuff
- truncate lengths, other doubles or more compactly write
- why are traversable lines given not as point sequence?

    - get rid of map_fn
    - convert to Common in all cases
    - get rid of geometryless mode
    - why set_params?
    - too much being serialized? about 8mb too big...
    - dont need to plumb scenarios to sim anymore,
      but it could be useful for viral stuff?

# Distributed Parallelization
- meseoscopic in between regions? lockstep necessary?
- dynamic load balancing? any need to split up by region?
- actors / akka?

# Applications
- follow dist variable based on speed, so when a light goes green,
  everyone starts simultaneously
- contraflow
- dynamic replanning + hierarchial planning (wards)
- rewindable simulation

# Theoretical
- is there a way to analytically say "an agent will own this chunk" at some time, and
  then solve for collisions?
- can we make timesteps equivalent? (probably not)
- varying dt mid-simulation

# Administrative
- website
  - build instructions (with scala and such)
  - wiki docs
  - scaladoc
- osm scraper script
- rename lanes/intersections/junctions in code too? policy -> controller?
- switch ant to sbt? https://github.com/harrah/xsbt/wiki/Examples
- repository of detailed cities with demand data?
