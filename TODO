# TODO #

- stats
  - commandline to enable/disable it
  - Util should own it
  - how fine-tuned? (time, speed of each agent) or (time, average speed now)
  - stream to a logfile

  - how long did simulation run (just one value)
  - how long did each agent take to complete a trip?
  - how long did each agent idle total?
  - throughput of intersections (agents completing a turn per...)
  - total distance by all vehicles
  - if an agent was the only car and never had to stop and did speed limit, what would they get? difference from that is delay per agent.

- improve pre-emption in stop lights + reservation policies. agent in front of them better be
  approved too.

- implement standard civeng phasal traffic signal behavior

- how fast can we generate lots of dumb agents?
  maybe print progress

- consider letting intersections react on their own, rather than just from agents
  simplifies reasoning about traffic signals, but also takes away the sorta clever delay-avoider.
  - optimization: intersections schedule events "hey wake me up >= this tick" so we dont poll all

TRAFFIC SIGNAL
  - each intersection has a sequence of cyclic 'cycles' and an 'offset':
    - cycle = (a set of non-conflicting turns, a duration)
    - initial offset = all signals start with first at the first cycle at 0 seconds + this extra time

  1) fixed allocation
    - no offsets, common delay, arbitrary sets (maybe try to group all from same lane)
  2) random allocation
    - random offset and delay within some bound, arbitrary sets
  3) green-wave forwards allocation ("greenflood")
    - make the abstraction for SignalPolicy to have a CycleConfig, then fill it out
      - test and make sure it produces exact same results
    - real-time viz as the lights change
      - requires overseer, unless cars are at that intersection
    - finish greenflood
      - prefer turns to major roads first (or major->major is better than minor->major?)
        (or alternate between these preferences)

  4) diffused backwards allocation
    - same idea, but goal: make one critical intersection super efficient
    - what lanes lead to / feed the lanes that can do turns? repeat for those.

BUGS
  - (50,000; drunken behavior; BTR; seed 1330434688570; time ~18.6) illegal entry by a2192

PROFILING
  - we can do much better with ready agents... max capacity of edges, group them based on where they
    want to spawn, maybe by generator?
  - dont ask length of a list when not needed...
  - how fast can we generate lots of dumb agents?

  1) is caching properties of linked list hurting us for iterating through big things?
  3) ... increase dt, of course
  4) optimize step/react -- those take the most work time
    - if an agent is dependent on another and nothing changed with them, dont even bother?
    - when nothing changes, short-circuit lots of stuff?

GENERATORS
  - a way to turn them off / reap them in the UI
  - color agents from diff generators a certain way
  - a way to save a "scenario"
  - test at scale, and profile again.

BIGGER ISSUES
  - fix geom of edge lines
  - make sure turns and conflicts are as good as possible
    - randomize num of lanes to test
  * lane changing
  - is there a way to analytically say "an agent will own this chunk" at some time, and then solve for collisions?
  - nondeterministic.
    - when running, agents enter at diff times
    - when paused, threads compute routes in diff orders, then two agents compete to spawn in same spot.
  - automated testing strategy.
  - contraction hierarchies for FAST pathing, or wards
  - group crazy intersections together and have S-turns.
    - relatedly, have a notion of "I'm done with the turn, but I'm protruding into the intersection"
      by requiring not only we're done with a turn but also some dist along the new edge.

POSSIBLY SIMPLE
  - slow down for turns (a speed limit)
  - follow dist variable based on speed, so when a light goes green,
    everyone starts simultaneously
  - tweak cfg now that we have meters
  - script to scrape osm
  - switch ant to sbt? https://github.com/harrah/xsbt/wiki/Examples
  - when we speed up, sleep less in UI?
  - ui configurable intersection policies
  - snapshot mode in headless with agents pos, to later render

### Map building ###

- our pruning of pedestrian ways seems to be a bit too enthusiastic (see Guadalupe St)
- deterministic construction is still wonky, with both ward IDs and lines (due to meeting up)
- make line segs meet up better.
- style: xml out could be string.format or xml and then stringify, or use lazy?
- cul-de-sac handling in p2... needed?
  - Claus Circle in BR... has no outgoing turns.
- pregraph3 vs final graph structure?
- multi-lane situations dont have enough turns, and we need to do more trimming!
- lane reversal
  1) Traversable.location starts from the other end (distances, queues all stay same)
  2) dynamically recalculating turns

### Wards ###

- whats broken with mikes?
  - length
  - overall strategy
  - semantics of one of the set operations
- find 'major' roads better
  - crosses/links major roads
  - manually editing
  - update osm (scripts!)
- my wards!
  - guarantee some kind of connectedness within a ward
  - except in vs out edges to the whole neighborhood?
- play with min span trees for pathing

### UI ###

- show 'fps' in viewer
- agents in middle of road makes ends of lines once again look sucky.
- show agents who are currently GOING
  - ui could show policy's current owner or something
- show routes better
- config
- menu items doing stuff
- make it look nicer
  - UI polishing
  - black road backgrounds dont meet up smoothly since we go by line segment
    - add extra lanes on either side, dont color them white, but draw the stuff in between?
- way better pruning of what to (re-draw) using quadtrees
  - but is it even needed?
- dont show arrows when line segs are really clustered
- draw the orig corner of freehanded polygons differently or something

### Agents ###

- post-mortem queue checker still misses scary things in between, like when merging.
- lots of things break if we have a vertex with a self-loop
- make them slow down for turns
- lanechanging model
- spawning specifically in UI
- structuring policy stuff as a state machine and events may be more elegant...
- give lanes/roads/etc the ability to be closed
- we could check less queues atomically if we could step agents in some cool order
  - or when we mess with an agent, see if they've moved yet this round?

### Scalaisms ###

- move all configable things to Util
- use ListBuffers more.
- make more immutable things
- reduce more vars to vals
- make everything possible immutable, but then have to figure out how to build
  inter-referential things
  - Mutable subclasses of everything used during construction..
  - have more ids and methods that access based on those. that'll break it.
- explicitly override hashcode?

### Simulation ###

- tolling (not trolling)
- lane reversal
- traffic signals
- dynamic traffic signals
- spawning realistic traffic patterns
  http://sumo.sourceforge.net/doc/current/docs/userdoc/Demand/Introduction_to_demand_modelling_in_SUMO.html
  http://sumo.sourceforge.net/doc/current/docs/userdoc/Data/Traffic_Data.html
- promoting stop signs -> lights
- mixing intersections!

### Administrative ###

- documentation
- API and code freeze
- paper
