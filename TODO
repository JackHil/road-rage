# TODO #

# Current

LANE-CHANGE
  - stats: how often do we want to LC but cant? (total that miss it)
  - talk to intersection earlier?
  - static routes eat memory and are slow!
    - contraction hierarchies, hub labeling, etc
  - why do we need to asap warp to new lane when we start LCing again?
    (lookahead)
  - lookbehind for lanechanging and spawning. lazily compute.
  - consider stalling to wait to LC
  - consider better pass3 reachability analysis
  - implement speculative desired_lane

CHECKPOINTING
  - trigger it auomatically, right filenames
  - efficient format, but converters btwn human-readable
  - hard to save rng, so reset seed before checkpointing
  - scala auto-serialization, ad-hoc, collect state?

OPTIMIZE
  - boxing with doubles is slow..
  - turn off all assertions, timers...
  - reduce memory by throwing away geometry in headless mode
    (and even in non-headless, if we wind up with awt stuff in the gui)
  - dont keep asking the same thing over and over again in lookahead
    - remember our limiting factor from last time and check it again?
      but when could new agents crop up in between?
  - parallelize lookahead within a timestep
  - profiling times dont add up. renice?
  - save memory by excluding lines/points, except from gui?
  - hotspot just doesnt kick in soon enough
  - go back and optimize spawning
  - ui should sleep better
  - more compact format than xml? :P  even json...

TEST
  - is it really safe to tweak dt? epsilons may depend on it.

# Lane changing

- new lookahead is not requesting turn till already stopped, even with reservation!
- dont forget to look at agent ahead of us in old lane only.
- agents get caught in loops because the general path isnt realizable

- test at scale. gridlock?

- ui draw them better
  - two types of positions?
  - each obj should have a render()
  - spawning agents at specific places
- ui visualize safe spawning distances
- testing
  - introduce automated test framework using scenarios
  - wacky cases of 2 side-by-side agents wanting to swap places?

# Uber stuff
re-evaluate the idea of this.

DOING IT
  - still flood, then make new vert and turns, and mod old edges?
  - save uber-turns and extend turn, with lines/a notion of saved conflict?
  - track conflicts online by doing vert relaxation slowly?
  - emphasize mixed policies

TESTING IT
  - what if there are too many uberturns somewhere?
  - make sure we have determinism
  - collision avoidance in many situations, with many dt's
  - make sure gridlock is detected
  - observe a case where doing this helps some situation

# Administrative
- improve scripts to not rebuild maps often
- website
  - build instructions (with scala and such)
  - osm scraper script
  - wiki docs
  - scaladoc
- rename lanes/intersections/junctions in code too?
  - rename policy -> controller
- is there a way to analytically say "an agent will own this chunk" at some time, and
  then solve for collisions?
- switch ant to sbt? https://github.com/harrah/xsbt/wiki/Examples

# Problems
- calibration issues... distances totally off
- fix the dumb illegal entry epsilon bugs.
  - why was the hack in map.make.Checker needed?
  - a conflict between a too-big stopping distance and acceleration into negative speed...
    - suggests it was an impossible request anyway?
  - directly compute the accel to end in dist.
  - lookahead by end_thres more than current.
  - why are we EVER doomed?!
  - why are we EVER requesting negative accel_to_end distances?
- jvm crashing on some jvm implementations?

# Behaviors, Policies, & Strategies
- traffic signal
  - try backpressure idea
  - visualize the green/red better
    - do something with lanes still
    - what i was imagining was picking some edge at some point in time, then flooding out
      from there at some rate.
  - improve greenflood
  - diffused backwards allocation
    - same idea, but goal: make one critical intersection super efficient
    - what lanes lead to / feed the lanes that can do turns? repeat for those.
- structuring policy stuff as a state machine and events may be more elegant...

# Profiling
- optionally gzipping maps/osm?
- we can do much better with ready agents... max capacity of edges, group them based on
  where they want to spawn, maybe by generator?
- in react if speed is still 0, see if follow_agent or intersection has changed.
- is caching properties of linked list hurting us for iterating through big things?
- we could check less queues atomically if we could step agents in some cool order
  - or when we mess with an agent, see if they've moved yet this round?

# Parallelizing
- parallelize lookahead?
  - safe_to_lanechange looks at other agents in a queue...
  - entering/exit queue to lanechange or be done with route (lock per queue)
  - canceling intersection reservations (lock per vert)
  - lookahead looks for things close by on queues.
  - polling intersections
  => observing readonly state of simulation would be useful. this is another
     argument for reverse computation.
- meseoscopic in between regions? lockstep necessary?
- dynamic load balancing? any need to split up by region?
- actors / akka?

# UI
1) draw map as an svg, see how fast that can be rendered by anything
2) see how fast p3d can render static geometry
3) java3d optimized for static scenes?
- http://technically.us/code/x/flocking-with-spde/
  consider processing, partial 3d rendering of overpasses.
- turn off generators
- color agents from diff generators a certain way
- when we speed up, sleep less in UI?
- configurable intersection policies
- in sugarland, oneway bg lines arent thick enough
- get rid of arrows, make roads transparent, change colors, something.
  - dont show arrows when line segs are really clustered
- show 'fps' in viewer
- agents in middle of road makes ends of lines once again look sucky.
- show agents who are currently GOING
  - ui could show policy's current owner or something
- show routes better
- onfig
- black road backgrounds dont meet up smoothly since we go by line segment
  - add extra lanes on either side, dont color them white, but draw the stuff in between?
- way better pruning of what to (re-draw) using quadtrees
  - but is it even needed?
- draw the orig corner of freehanded polygons differently or something

# Map Gen
- use http://wiki.openstreetmap.org/wiki/Relation:restriction
- fix geom of edge lines
- make sure turns and conflicts are as good as possible
  - randomize num of lanes to test
- our pruning of pedestrian ways seems to be a bit too enthusiastic (see Guadalupe St)
- deterministic construction is still wonky, with ward IDs and lines (due to meeting up)
- make line segs meet up better.
- style: xml out could be string.format or xml and then stringify, or use lazy?
- cul-de-sac handling in p2... needed?
  - Claus Circle in BR... has no outgoing turns.
- multi-lane situations dont have enough turns, and we need to do more trimming!

# General Simulation
- reverse simulation! find a problem, go backwards in time
  - characterizing where everything is is easy, capturing internal state is hard
  - characterize evertyhing that happens that causes state change, make it undoable.
  - another benefit... if queue does error checking against old state of queue, does that help? (i think not...)

- osm/ and maps/ separate
- modular design... if one agent breaks, dont break everyone
- have a notion of "I'm done with the turn, but I'm protruding into the intersection"
  by requiring not only we're done with a turn but also some dist along the new edge.
- slow down for turns (a speed limit)
- snapshot mode in headless with agents pos, to later render
  (solve memory issue)
- tweak cfg now that we have meters
- give lanes/roads/etc the ability to be closed
- lots of things break if we have a vertex with a self-loop
- determinism: worker threads while running (can't help this)

# Applications
- follow dist variable based on speed, so when a light goes green,
  everyone starts simultaneously
- contraflow
  1) Traversable.location starts from the other end (distances, queues all stay same)
  2) dynamically recalculating turns
- dynamic replanning + hierarchial planning
- microtolling (not trolling)
- traffic signals that learn
- promoting stop signs -> lights
  - mixing intersections!

# Wards
- find 'major' roads better
  - crosses/links major roads
  - manually editing
  - update osm (scripts!)
- my wards!
  - guarantee some kind of connectedness within a ward
  - except in vs out edges to the whole neighborhood?

# Code Cleanup
- move all configable things to Util
- make more immutable things / reduce more vars to vals
- make everything possible immutable, but then have to figure out how to build
  inter-referential things
  - Mutable subclasses of everything used during construction..
  - have more ids and methods that access based on those. that'll break it.
  - immutable construction is easy... have parent entity create child.

# Testing Strategy
- determinism
  - how to test it?
  - how to use it?
- things to test
  - invariance of dt_s
