# TODO #

- proximity violations remain.
- there actually is ALMOST atomicity. steps happen sequentially but are unconcious.
  react() moves agents to target LC queue asap.. thats bad. dont do it till step! then worry about collisions, reverting. (what priority wins?)
- ui speed controls.. step one tick, display a certain fps, sleep to match what?

# Optimizations
- reduce memory by throwing away geometry in headless mode
  (and even in non-headless, if we wind up with awt stuff in the gui)
- maps: more compact format than xml? :P  even json...
  - why are traversable lines given not as point sequence?

# Lane changing
- agents get caught in loops because the general path isnt realizable
- dont let agents start lc that depends on others getting out of way
- lookbehind is feasible with lazy floodfilling
- speculative desired_lane

- test at scale. gridlock?

- testing
  - introduce automated test framework using scenarios
  - wacky cases of 2 side-by-side agents wanting to swap places?

# Uber stuff
re-evaluate the idea of this.

DOING IT
  - still flood, then make new vert and turns, and mod old edges?
  - save uber-turns and extend turn, with lines/a notion of saved conflict?
  - track conflicts online by doing vert relaxation slowly?
  - emphasize mixed policies

TESTING IT
  - what if there are too many uberturns somewhere?
  - make sure we have determinism
  - collision avoidance in many situations, with many dt's
  - make sure gridlock is detected
  - observe a case where doing this helps some situation

# Administrative
- improve scripts to not rebuild maps often
- website
  - build instructions (with scala and such)
  - osm scraper script
  - wiki docs
  - scaladoc
- rename lanes/intersections/junctions in code too?
  - rename policy -> controller
- is there a way to analytically say "an agent will own this chunk" at some time, and
  then solve for collisions?
- switch ant to sbt? https://github.com/harrah/xsbt/wiki/Examples
- repository of detailed cities with demand data?

# Problems
- calibration issues... distances totally off
- fix the dumb illegal entry epsilon bugs.
  - why was the hack in map.make.Checker needed?
  - a conflict between a too-big stopping distance and acceleration into negative speed...
    - suggests it was an impossible request anyway?
  - directly compute the accel to end in dist.
  - lookahead by end_thres more than current.
  - why are we EVER doomed?!
  - why are we EVER requesting negative accel_to_end distances?
- jvm crashing on some jvm implementations?
- is it really safe to tweak dt? epsilons may depend on it.
- different vehicle lengths, parameters

# Behaviors, Policies, & Strategies
- traffic signal
  - cycles have to last long enough to let agent cross long intersection
  - try backpressure idea
  - visualize the green/red better
    - do something with lanes still
    - what i was imagining was picking some edge at some point in time, then flooding out
      from there at some rate.
  - improve greenflood
  - diffused backwards allocation
    - same idea, but goal: make one critical intersection super efficient
    - what lanes lead to / feed the lanes that can do turns? repeat for those.
- reservations
  - use backpressurelike idea with inertia
- structuring policy stuff as a state machine and events may be more elegant...

# Profiling
- sleep less in UI
- optionally gzipping maps/osm?
- we can do much better with ready agents... max capacity of edges, group them based on
  where they want to spawn, maybe by generator?
- in react if speed is still 0, see if follow_agent or intersection has changed.
- is caching properties of linked list hurting us for iterating through big things?
- we could check less queues atomically if we could step agents in some cool order
  - or when we mess with an agent, see if they've moved yet this round?

# Parallelizing
- parallelize lookahead?
  - safe_to_lanechange looks at other agents in a queue...
  - entering/exit queue to lanechange or be done with route (lock per queue)
  - canceling intersection reservations (lock per vert)
  - lookahead looks for things close by on queues.
  - polling intersections
  => observing readonly state of simulation would be useful. this is another
     argument for reverse computation.
- meseoscopic in between regions? lockstep necessary?
- dynamic load balancing? any need to split up by region?
- actors / akka?

# UI
- better code, everything needs debug() and render()
- visualize lookahead
- work on svg
- see how fast p3d can render static geometry
- java3d optimized for static scenes?
- the renderer for osm is actually nice..
- http://technically.us/code/x/flocking-with-spde/
  consider processing, partial 3d rendering of overpasses.
- turn off generators
- color agents from diff generators a certain way
- when we speed up, sleep less in UI?
- configurable intersection policies. and rep them better!
- right click context menus
- in sugarland, oneway bg lines arent thick enough
- get rid of arrows, make roads transparent, change colors, something.
  - dont show arrows when line segs are really clustered
- show 'fps' in viewer
- agents in middle of road makes ends of lines once again look sucky.
- show agents who are currently GOING
  - ui could show policy's current owner or something
- show routes better
- onfig
- black road backgrounds dont meet up smoothly since we go by line segment
  - add extra lanes on either side, dont color them white, but draw the stuff in between?
- way better pruning of what to (re-draw) using quadtrees
  - but is it even needed?
- draw the orig corner of freehanded polygons differently or something

# Map Gen
- use http://wiki.openstreetmap.org/wiki/Relation:restriction
- fix geom of edge lines
- make sure turns and conflicts are as good as possible
  - randomize num of lanes to test
- our pruning of pedestrian ways seems to be a bit too enthusiastic (see Guadalupe St)
- deterministic construction is still wonky, with ward IDs and lines (due to meeting up)
- make line segs meet up better.
- style: xml out could be string.format or xml and then stringify, or use lazy?
- cul-de-sac handling in p2... needed?
  - Claus Circle in BR... has no outgoing turns.
- multi-lane situations dont have enough turns, and we need to do more trimming!
- connectivity fixpoint algorithm shouldnt be necessary?

# General Simulation
- calibrate parameters.
- osm/ and maps/ separate
- modular design... if one agent breaks, dont break everyone
- have a notion of "I'm done with the turn, but I'm protruding into the intersection"
  by requiring not only we're done with a turn but also some dist along the new edge.
- slow down for turns (a speed limit)
- snapshot mode in headless with agents pos, to later render
  (solve memory issue)
- tweak cfg now that we have meters
- give lanes/roads/etc the ability to be closed
- lots of things break if we have a vertex with a self-loop
- determinism: worker threads while running (can't help this)
  - record when we introduce somebody, resim enforces this and blocks.

# Applications
- follow dist variable based on speed, so when a light goes green,
  everyone starts simultaneously
- contraflow
- dynamic replanning + hierarchial planning
- microtolling (not trolling)
- traffic signals that learn
- promoting stop signs -> lights
  - mixing intersections!

# Wards
- find 'major' roads better
  - crosses/links major roads
- my wards!
  - guarantee some kind of connectedness within a ward
  - except in vs out edges to the whole neighborhood?

# Code Cleanup
- move all configable things to Util
- make more immutable things / reduce more vars to vals
- make everything possible immutable, but then have to figure out how to build
  inter-referential things
  - Mutable subclasses of everything used during construction..
  - have more ids and methods that access based on those. that'll break it.
  - immutable construction is easy... have parent entity create child.

# Testing Strategy
- determinism
  - how to test it?
  - how to use it?
- things to test
  - invariance of dt_s
