# TODO #

# Roadmap #

1) cleanup
  - scenario serialization
    - so, totally rip out old way.
  - instructions on site
  - clever routing
  - good enough default sys bids, to get new default over FIFO
  - fix up maps once and for allish
  - common case policy, in places like claycut rd
  - sim speed
    - turn blocked invariant, really maintain it for efficiency!
  - ui
    - total rewrite in something
    - viz: color roads thatre planned for use
  - gridlock is still a stigma
  - bugs
    - agents not stopping at exactly the right dist the first time
    - trip time should include waiting to enter time
  - savestating
    - resuming logging
    - multiple sims existing per process better. stats object.
2) big breaux
3) marginal effects

# Clever routing #

- reroute when necessary
  - before we hit a jam (k-lookahead...)
  - semi-constantly (D*Lite ?)
- tradeoff between congested routes and distance
- spectrum of congestedness
- worry about liveness?

# Auctions #

- cleanup
  - tune sysbids properly...
  - sys wallet can punish by dividing.. also, doubles
  - multiple bids for same item.. handle that
  - define losers generally in code too
  - agents not stopping at exactly the right dist the first time, makes stop signs slow.

- system bid: bonus to reservation if i'll take the same time as somebody else
- commoncase auctions and system bid
  - reservation with certain system bid for compatible turns

# Easy Parallelization
- PARALLEL DETERMINISM INVALID: queue avail_slots

- how to PAR
  - benchmark carefully

- easy PAR
  - queue end_step
  - intersection end_step
  - intersection reaction
  - lookahead

- hard PAR: agent steps
  - dont forget handle_exit
  - LCing means chunking by road
  - figure out where everyone ends up, then merge queues in one thread?

# Fastpaths / Sparse Execution
- agents and intersections could wake each other up now

# Map Construction
- fix new small issues..
  - floating vertices due to nuking all roads that lead up to it, and choosing
    the vert to keep poorly
  - not seeing any geometry is a bit disconcerting... gov st
- num of lanes bounded by num of times could LC
- handle cul de sacs once and for all... bernwood is example in BR. remove if
  only one other link?
- dont tie map filename to the serialized thing
- var lines are so confusing and bug-prone
  when we mod part of a line, line's length AND traversables length gets screwed
  get rid of set_lines
- keep orig GPS coords and only scale around for UI
  - then obselete set_params
- xml output too for non-aorta clients
- clean up verts with just 2 roads
  - pass3, since doomed pruning makes new problems
  - but keep pass 2 version? seems to prevent some stuff from getting doomed!
- short roads into longer turns
  - 50 meters?
  - dont nix roads connected to vertices with only one road!
  - bernwood drive and other places where the number blows up

  - fix the geometry stuff later. what stuff?
    - maybe remove set_lines?
  - remove ui debugging stuff
- make turns better, more systematically
  - try to not remove pieces of maps at all

- use http://wiki.openstreetmap.org/wiki/Relation:restriction
- our pruning of pedestrian ways seems to be a bit too enthusiastic (see Guadalupe St)
- deterministic construction is still wonky, with lines meeting up
- cul-de-sac handling in p2... needed?
  - Claus Circle in BR... has no outgoing turns.
- connectivity fixpoint algorithm shouldnt be necessary?
- lots of things break if we have a vertex with a self-loop

# Simulation Realism
- slow down for turns (a speed limit)
- diversity... different vehicle lengths, parameters
- calibration issues... distances totally off
- give lanes/roads/etc the ability to be closed

# Code Cleanup
- using new ID stuff, make copies of stuff instead of var?
- distance/time types
- compatible serialization
- split the passes
  - pass1 = read osm + normalize
  - pass2 = pass2
  - pass3 = (>make edge geometry), make edges, make turns,
            (>nuke disconnected), (collapse degenerate verts),
            (small roads to long turns), trim lane lines at vertices
- draw per object
  - UI state needs to go somewhere accessible to all
  - package for awt stuff to avoid importing
- sorted sets everywhere for determinism
- more privates, make abstract members more explicit, delegates
- make more immutable things / reduce more vars to vals
- make everything possible immutable, but then have to figure out how to build
  inter-referential things
  - Mutable subclasses of everything used during construction..
  - have more ids and methods that access based on those. that'll break it.
  - immutable construction is easy... have parent entity create child.

# Intersection Policies
- backpressure light optimization
- do it faster with invariants, look at just the next guy
  - BUT we can be route-done, but have somebody blocking in front of us
    initially. so in that case, search forward?
    - this only happens because we join a queue without demanding invariants of
      stuff in front of us
- make new stuff faster, mark when first elgiible or something with very
  powerful FPs
  - aka candidate list can be greatly narrowed, or ordered

# Scaling
- tighten memory usage, although 1GB supports 1 million agents
- we can do much better with ready agents... max capacity of edges, group them
  based on where they want to spawn, maybe by generator?
- gridlock
  - increase avail slots when we're accepted, not leaving (except route end)
  - when we accept early and check for blockedness, see if theyre anywhere close
    to the turn yet! moot point if the turns not blocked when they ask...
    - aka, make all policies do 'is anyone ahead of you unaccepted'
  - force different turns?
- at big timesteps, nobody moves?

# Testing/Experiments
- bug: experiment script unserializes objects twice
- standalone programs to make/mod scenarios
  - specify distribution of rand things, discrete or continuous.
  - breakdown other categories when describing
- make scenarios from UI
- poisson for introducing vehicles
- things to test
  - wacky cases of 2 side-by-side agents wanting to swap places?

# UI
- merge headless/gui clients
- step one tick
- label agents with their number in the GUI
- javafx?
- 3D. ardor? jme?
- visualize red/green lights better
- cmdline switch to follow stuff or zoom in somewhere
- visualize lookahead
- turn off generators
- color agents from diff generators a certain way
- right click context menus
- show 'fps' in viewer

# Lane-changing
- roads arent shortened enough when conservative lookahead picks too high a speed, then caps itself... two brief passes, to get the right amount of lookahead? :P
- any missed opportunities?
- dont let agents start lc that depends on others getting out of way. till then,
  funky patterns of backup
- speculative desired_lane
- road lengthening means we dont have to reduce numbers of lanes for LCing
- removal approach doesnt handle having to LC many times on one road

# Applications
- follow dist variable based on speed, so when a light goes green,
  everyone starts simultaneously
- contraflow
- dynamic replanning + hierarchial planning (wards)

# Theoretical
- is there a way to analytically say "an agent will own this chunk" at some time, and
  then solve for collisions?

# Administrative
- website
  - build instructions (with scala and such)
  - wiki docs
  - scaladoc
  - domain name?
- osm scraper script
  https://github.com/migurski/Extractotron/
- rename lanes/intersections/junctions in code too? policy -> controller?
- switch ant to sbt? https://github.com/harrah/xsbt/wiki/Examples
- repository of detailed cities with demand data?
