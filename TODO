# TODO #

# Uber stuff
DOING IT
  - still flood, then make new vert and turns, and mod old edges?
  - save uber-turns and extend turn, with lines/a notion of saved conflict?
  - track conflicts online by doing vert relaxation slowly?

TESTING IT
  - what if there are too many uberturns somewhere?
  - make sure we have determinism
  - make sure gridlock is detected
  - observe a case where doing this helps some situation

# Administrative
- video
- improve scripts to not rebuild maps often
- website
  - build instructions (with scala and such)
  - osm scraper script
  - wiki docs
  - scaladoc
- rename lanes/intersections/junctions in code too?
  - rename policy -> controller
- is there a way to analytically say "an agent will own this chunk" at some time, and
  then solve for collisions?
- switch ant to sbt? https://github.com/harrah/xsbt/wiki/Examples

# Problems
- fix the dumb illegal entry epsilon bugs.
  - why was the hack in map.make.Checker needed?
  - a conflict between a too-big stopping distance and acceleration into negative speed...
    - suggests it was an impossible request anyway?
  - directly compute the accel to end in dist.
  - lookahead by end_thres more than current.
  - why are we EVER doomed?!
  - why are we EVER requesting negative accel_to_end distances?
- gridlock
  - make them re-route?
  - verify lane-changing is the problem

# Behaviors, Policies, & Strategies
- traffic signal
  - visualize the green/red better
    - do something with lanes still
    - what i was imagining was picking some edge at some point in time, then flooding out
      from there at some rate.
  - improve greenflood
  - diffused backwards allocation
    - same idea, but goal: make one critical intersection super efficient
    - what lanes lead to / feed the lanes that can do turns? repeat for those.
- structuring policy stuff as a state machine and events may be more elegant...

# Profiling
- we can do much better with ready agents... max capacity of edges, group them based on
  where they want to spawn, maybe by generator?
- measure profiling things
  - how long did simulation run? (one value)
- in react if speed is still 0, see if follow_agent or intersection has changed.
- is caching properties of linked list hurting us for iterating through big things?
- think about parallelizing
- contraction hierarchies for FAST pathing, or wards
- we could check less queues atomically if we could step agents in some cool order
  - or when we mess with an agent, see if they've moved yet this round?

# UI
- turn off generators
- color agents from diff generators a certain way
- when we speed up, sleep less in UI?
- configurable intersection policies
- in sugarland, oneway bg lines arent thick enough
- get rid of arrows, make roads transparent, change colors, something.
  - dont show arrows when line segs are really clustered
- show 'fps' in viewer
- agents in middle of road makes ends of lines once again look sucky.
- show agents who are currently GOING
  - ui could show policy's current owner or something
- show routes better
- config
- black road backgrounds dont meet up smoothly since we go by line segment
  - add extra lanes on either side, dont color them white, but draw the stuff in between?
- way better pruning of what to (re-draw) using quadtrees
  - but is it even needed?
- draw the orig corner of freehanded polygons differently or something

# Map Gen
- use http://wiki.openstreetmap.org/wiki/Relation:restriction
- fix geom of edge lines
- make sure turns and conflicts are as good as possible
  - randomize num of lanes to test
- our pruning of pedestrian ways seems to be a bit too enthusiastic (see Guadalupe St)
- deterministic construction is still wonky, with ward IDs and lines (due to meeting up)
- make line segs meet up better.
- style: xml out could be string.format or xml and then stringify, or use lazy?
- cul-de-sac handling in p2... needed?
  - Claus Circle in BR... has no outgoing turns.
- multi-lane situations dont have enough turns, and we need to do more trimming!

# Lane changing
- key: pathfind by directed roads (clumps of lanes), leave specific turns and lanes up to
  behavior. still allow for re-planning (if we miss road entirely or part of road explodes).
- logically, geometrically
- when is it safe?
  - dont try it too close to the end or beginning
  - guarantee to avoid agents
  - atomic; dont start without finishing
  - dont attempt on short lanes
- how does the agent look during it?
  - how long does it take? is it a fxn of speed?
  - stay in both queues during
- how are routes affected if it's missed/impossible?
  - is it OK to stall forever and wait to merge in?
- wacky cases of 2 side-by-side agents wanting to swap places?
- purpose
  - for now, just routing
  - much later, a behavior could do it within constraints of route to pass slow?

# General Simulation
- automated testing strategy.
- have a notion of "I'm done with the turn, but I'm protruding into the intersection"
  by requiring not only we're done with a turn but also some dist along the new edge.
- slow down for turns (a speed limit)
- snapshot mode in headless with agents pos, to later render
  (solve memory issue)
- tweak cfg now that we have meters
- give lanes/roads/etc the ability to be closed
- lots of things break if we have a vertex with a self-loop
- determinism: worker threads while running (can't help this)

# Applications
- follow dist variable based on speed, so when a light goes green,
  everyone starts simultaneously
- contraflow
  1) Traversable.location starts from the other end (distances, queues all stay same)
  2) dynamically recalculating turns
- dynamic replanning + hierarchial planning
- microtolling (not trolling)
- traffic signals that learn
- promoting stop signs -> lights
  - mixing intersections!

# Wards
- whats broken with mikes?
  - length
  - overall strategy
  - semantics of one of the set operations
- find 'major' roads better
  - crosses/links major roads
  - manually editing
  - update osm (scripts!)
- my wards!
  - guarantee some kind of connectedness within a ward
  - except in vs out edges to the whole neighborhood?

# Code Cleanup
- move all configable things to Util
- make more immutable things / reduce more vars to vals
- make everything possible immutable, but then have to figure out how to build
  inter-referential things
  - Mutable subclasses of everything used during construction..
  - have more ids and methods that access based on those. that'll break it.
  - immutable construction is easy... have parent entity create child.
